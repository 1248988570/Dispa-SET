

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>DispaSET.preprocessing.utils &mdash; Documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> DispaSET
          

          
            
            <img src="../../../_static/logo.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                2.3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../releases.html">Releases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../workflow.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../model.html">Model Description</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../formulations.html">Model Formulations and clustering</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../implementation.html">Implementation and interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../data.html">Input Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../cases.html">Case Studies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../developers.html">Developersâ€™ section</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../DispaSET.html">DispaSET package</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">DispaSET</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>DispaSET.preprocessing.utils</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for DispaSET.preprocessing.utils</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This file gathers different functions used in the DispaSET pre-processing tools</span>

<span class="sd">@author: Sylvain Quoilin (sylvain.quoilin@ec.europa.eu)</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span>

<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>

<span class="kn">from</span> <span class="nn">..misc.str_handler</span> <span class="k">import</span> <span class="n">clean_strings</span><span class="p">,</span> <span class="n">shrink_to_64</span>


<div class="viewcode-block" id="incidence_matrix"><a class="viewcode-back" href="../../../DispaSET.preprocessing.html#DispaSET.preprocessing.utils.incidence_matrix">[docs]</a><span class="k">def</span> <span class="nf">incidence_matrix</span><span class="p">(</span><span class="n">sets</span><span class="p">,</span> <span class="n">set_used</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">param_used</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function generates the incidence matrix of the lines within the nodes</span>
<span class="sd">    A particular case is considered for the node &quot;Rest Of the World&quot;, which is no explicitely defined in DispaSET</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sets</span><span class="p">[</span><span class="n">set_used</span><span class="p">])):</span>
        <span class="k">if</span> <span class="s1">&#39;RoW&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sets</span><span class="p">[</span><span class="n">set_used</span><span class="p">][</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">first_country</span> <span class="o">=</span> <span class="n">sets</span><span class="p">[</span><span class="n">set_used</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">second_country</span> <span class="o">=</span> <span class="n">sets</span><span class="p">[</span><span class="n">set_used</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="mi">6</span><span class="p">:</span><span class="mi">8</span><span class="p">]</span>
        <span class="k">elif</span> <span class="s1">&#39;RoW&#39;</span> <span class="o">==</span> <span class="n">sets</span><span class="p">[</span><span class="n">set_used</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]:</span>
            <span class="n">first_country</span> <span class="o">=</span> <span class="n">sets</span><span class="p">[</span><span class="n">set_used</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
            <span class="n">second_country</span> <span class="o">=</span> <span class="n">sets</span><span class="p">[</span><span class="n">set_used</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="mi">7</span><span class="p">:</span><span class="mi">9</span><span class="p">]</span>
        <span class="k">elif</span> <span class="s1">&#39;RoW&#39;</span> <span class="o">==</span> <span class="n">sets</span><span class="p">[</span><span class="n">set_used</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="mi">6</span><span class="p">:</span><span class="mi">9</span><span class="p">]:</span>
            <span class="n">first_country</span> <span class="o">=</span> <span class="n">sets</span><span class="p">[</span><span class="n">set_used</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">second_country</span> <span class="o">=</span> <span class="n">sets</span><span class="p">[</span><span class="n">set_used</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="mi">6</span><span class="p">:</span><span class="mi">9</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;The format of the interconnection is not valid.&#39;</span><span class="p">)</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sets</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">])):</span>
            <span class="k">if</span> <span class="n">first_country</span> <span class="o">==</span> <span class="n">sets</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">][</span><span class="n">j</span><span class="p">]:</span>
                <span class="n">parameters</span><span class="p">[</span><span class="n">param_used</span><span class="p">][</span><span class="s1">&#39;val&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">elif</span> <span class="n">second_country</span> <span class="o">==</span> <span class="n">sets</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">][</span><span class="n">j</span><span class="p">]:</span>
                <span class="n">parameters</span><span class="p">[</span><span class="n">param_used</span><span class="p">][</span><span class="s1">&#39;val&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">parameters</span><span class="p">[</span><span class="n">param_used</span><span class="p">]</span></div>


<div class="viewcode-block" id="interconnections"><a class="viewcode-back" href="../../../DispaSET.preprocessing.html#DispaSET.preprocessing.utils.interconnections">[docs]</a><span class="k">def</span> <span class="nf">interconnections</span><span class="p">(</span><span class="n">Simulation_list</span><span class="p">,</span> <span class="n">NTC_inter</span><span class="p">,</span> <span class="n">Historical_flows</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Function that checks for the possible interconnections of the countries included</span>
<span class="sd">    in the simulation. If the interconnections occurs between two of the countries</span>
<span class="sd">    defined by the user to perform the simulation with, it extracts the NTC between</span>
<span class="sd">    those two countries. If the interconnection occurs between one of the countries</span>
<span class="sd">    selected by the user and one country outside the simulation, it extracts the</span>
<span class="sd">    physical flows; it does so for each pair (country inside-country outside) and</span>
<span class="sd">    sums them together creating the interconnection of this country with the RoW.</span>

<span class="sd">    :param Simulation_list:     List of simulated countries</span>
<span class="sd">    :param NTC:                 Day-ahead net transfer capacities (pd dataframe)</span>
<span class="sd">    :param Historical_flows:    Historical flows (pd dataframe)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">index</span> <span class="o">=</span> <span class="n">NTC_inter</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">Historical_flows</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;The two input dataframes (NTCs and Historical flows) must have the same index. No common values have been found&#39;</span><span class="p">)</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">NTC_inter</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">Historical_flows</span><span class="p">):</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Historical_flows</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">NTC_inter</span><span class="p">))</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;The two input dataframes (NTCs and Historical flows) do not share the same index, although some values are common. The intersection has been considered and &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; data points have been lost&#39;</span><span class="p">)</span>
    <span class="c1"># Checking that all values are positive:</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">NTC_inter</span><span class="o">.</span><span class="n">values</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">NTC_inter</span><span class="o">.</span><span class="n">values</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;WARNING: At least NTC value is negative, for example in line &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">NTC_inter</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]])</span> <span class="o">+</span> <span class="s1">&#39; and time step &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">NTC_inter</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]]))</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Historical_flows</span><span class="o">.</span><span class="n">values</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">Historical_flows</span><span class="o">.</span><span class="n">values</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;WARNING: At least one historical flow is negative, for example in line &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">Historical_flows</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]])</span> <span class="o">+</span> <span class="s1">&#39; and time step &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">Historical_flows</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]]))</span>
    <span class="n">all_connections</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">simulation_connections</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># List all connections from the dataframe headers:</span>
    <span class="n">ConList</span> <span class="o">=</span> <span class="n">Historical_flows</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="o">+</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">NTC_inter</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">Historical_flows</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">tolist</span><span class="p">()]</span>
    <span class="k">for</span> <span class="n">connection</span> <span class="ow">in</span> <span class="n">ConList</span><span class="p">:</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; -&gt; &#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;WARNING: Connection &quot;&#39;</span> <span class="o">+</span> <span class="n">connection</span> <span class="o">+</span> <span class="s1">&#39;&quot; in the interconnection tables is not properly named. It will be ignored&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">Simulation_list</span><span class="p">:</span>
                <span class="n">all_connections</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">connection</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">Simulation_list</span><span class="p">:</span>
                    <span class="n">simulation_connections</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">connection</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">Simulation_list</span><span class="p">:</span>
                <span class="n">all_connections</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">connection</span><span class="p">)</span>

    <span class="n">df_countries_simulated</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">interconnection</span> <span class="ow">in</span> <span class="n">simulation_connections</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">interconnection</span> <span class="ow">in</span> <span class="n">NTC_inter</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">df_countries_simulated</span><span class="p">[</span><span class="n">interconnection</span><span class="p">]</span> <span class="o">=</span> <span class="n">NTC_inter</span><span class="p">[</span><span class="n">interconnection</span><span class="p">]</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Detected interconnection &#39;</span> <span class="o">+</span> <span class="n">interconnection</span> <span class="o">+</span> <span class="s1">&#39;. The historical NTCs will be imposed as maximum flow value&#39;</span><span class="p">)</span>
    <span class="n">interconnections1</span> <span class="o">=</span> <span class="n">df_countries_simulated</span><span class="o">.</span><span class="n">columns</span>

    <span class="c1"># Display a warning if a country is isolated:</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">Simulation_list</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">([</span><span class="n">c</span> <span class="ow">in</span> <span class="n">conn</span> <span class="k">for</span> <span class="n">conn</span> <span class="ow">in</span> <span class="n">interconnections1</span><span class="p">])</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">Simulation_list</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Zone &#39;</span> <span class="o">+</span> <span class="n">c</span> <span class="o">+</span> <span class="s1">&#39; does not appear to be connected to any other zone in the NTC table. It should be simulated in isolation&#39;</span><span class="p">)</span>

    <span class="n">df_RoW_temp</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">)</span>
    <span class="n">connNames</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">interconnection</span> <span class="ow">in</span> <span class="n">all_connections</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">interconnection</span> <span class="ow">in</span> <span class="n">Historical_flows</span><span class="o">.</span><span class="n">columns</span> <span class="ow">and</span> <span class="n">interconnection</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">simulation_connections</span><span class="p">:</span>
            <span class="n">df_RoW_temp</span><span class="p">[</span><span class="n">interconnection</span><span class="p">]</span> <span class="o">=</span> <span class="n">Historical_flows</span><span class="p">[</span><span class="n">interconnection</span><span class="p">]</span>
            <span class="n">connNames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">interconnection</span><span class="p">)</span>

    <span class="n">compare_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">connNames</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="ow">in</span> <span class="n">compare_set</span> <span class="ow">and</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="ow">in</span> <span class="n">Simulation_list</span><span class="p">:</span>
            <span class="n">compare_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">])</span>

    <span class="n">df_countries_RoW</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">compare_set</span><span class="p">:</span>
        <span class="n">nameToCompare</span> <span class="o">=</span> <span class="n">compare_set</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">exports</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">imports</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">connNames</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">nameToCompare</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="ow">in</span> <span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]:</span>
                <span class="n">exports</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">connNames</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Detected interconnection &#39;</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;, happening between a simulated zone and the rest of the world. The historical flows will be imposed to the model&#39;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">nameToCompare</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="ow">in</span> <span class="n">name</span><span class="p">[</span><span class="mi">6</span><span class="p">:</span><span class="mi">8</span><span class="p">]:</span>
                <span class="n">imports</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">connNames</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Detected interconnection &#39;</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;, happening between the rest of the world and a simulated zone. The historical flows will be imposed to the model&#39;</span><span class="p">)</span>

        <span class="n">flows_out</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">df_RoW_temp</span><span class="p">[</span><span class="n">connNames</span><span class="p">[</span><span class="n">exports</span><span class="p">[</span><span class="n">i</span><span class="p">]]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">exports</span><span class="p">)))</span>
        <span class="n">flows_out</span> <span class="o">=</span> <span class="n">flows_out</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">flows_out</span><span class="o">.</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">flows_out</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">nameToCompare</span> <span class="o">+</span> <span class="s1">&#39; -&gt; RoW&#39;</span>
        <span class="n">df_countries_RoW</span><span class="p">[</span><span class="n">nameToCompare</span> <span class="o">+</span> <span class="s1">&#39; -&gt; RoW&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">flows_out</span>
        <span class="n">flows_in</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">df_RoW_temp</span><span class="p">[</span><span class="n">connNames</span><span class="p">[</span><span class="n">imports</span><span class="p">[</span><span class="n">j</span><span class="p">]]]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">imports</span><span class="p">)))</span>
        <span class="n">flows_in</span> <span class="o">=</span> <span class="n">flows_in</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">flows_in</span><span class="o">.</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">flows_in</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;RoW -&gt; &#39;</span> <span class="o">+</span> <span class="n">nameToCompare</span>
        <span class="n">df_countries_RoW</span><span class="p">[</span><span class="s1">&#39;RoW -&gt; &#39;</span> <span class="o">+</span> <span class="n">nameToCompare</span><span class="p">]</span> <span class="o">=</span> <span class="n">flows_in</span>
    <span class="n">interconnections2</span> <span class="o">=</span> <span class="n">df_countries_RoW</span><span class="o">.</span><span class="n">columns</span>
    <span class="n">inter</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">interconnections1</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">interconnections2</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">df_countries_simulated</span><span class="p">,</span> <span class="n">df_countries_RoW</span><span class="p">,</span> <span class="n">inter</span><span class="p">)</span></div>



<div class="viewcode-block" id="clustering"><a class="viewcode-back" href="../../../DispaSET.preprocessing.html#DispaSET.preprocessing.utils.clustering">[docs]</a><span class="k">def</span> <span class="nf">clustering</span><span class="p">(</span><span class="n">plants</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;Standard&#39;</span><span class="p">,</span> <span class="n">Nslices</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">PartLoadMax</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">Pmax</span><span class="o">=</span><span class="mi">30</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Merge excessively disaggregated power Units.</span>

<span class="sd">    :param plants:          Pandas dataframe with each power plant and their characteristics (following the DispaSET format)</span>
<span class="sd">    :param method:          Select clustering method (&#39;Standard&#39;/&#39;LP&#39;/None)</span>
<span class="sd">    :param Nslices:         Number of slices used to fingerprint each power plant characteristics. slices in the power plant data to categorize them  (fewer slices involves that the plants will be aggregated more easily)</span>
<span class="sd">    :param PartLoadMax:     Maximum part-load capability for the unit to be clustered</span>
<span class="sd">    :param Pmax:            Maximum power for the unit to be clustered</span>
<span class="sd">    :return:                A list with the merged plants and the mapping between the original and merged units</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Checking the the required columns are present in the input pandas dataframe:</span>
    <span class="n">required_inputs</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Unit&#39;</span><span class="p">,</span> <span class="s1">&#39;PowerCapacity&#39;</span><span class="p">,</span> <span class="s1">&#39;PartLoadMin&#39;</span><span class="p">,</span> <span class="s1">&#39;RampUpRate&#39;</span><span class="p">,</span> <span class="s1">&#39;RampDownRate&#39;</span><span class="p">,</span> <span class="s1">&#39;StartUpTime&#39;</span><span class="p">,</span>
                       <span class="s1">&#39;MinUpTime&#39;</span><span class="p">,</span> <span class="s1">&#39;MinDownTime&#39;</span><span class="p">,</span> <span class="s1">&#39;NoLoadCost&#39;</span><span class="p">,</span> <span class="s1">&#39;StartUpCost&#39;</span><span class="p">,</span> <span class="s1">&#39;Efficiency&#39;</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">input_value</span> <span class="ow">in</span> <span class="n">required_inputs</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">input_value</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">plants</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;The plants dataframe requires a &#39;&quot;</span> <span class="o">+</span> <span class="n">input_value</span> <span class="o">+</span> <span class="s2">&quot;&#39; column for clustering&quot;</span><span class="p">)</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="s2">&quot;Nunits&quot;</span> <span class="ow">in</span> <span class="n">plants</span><span class="p">:</span>
        <span class="n">plants</span><span class="p">[</span><span class="s1">&#39;Nunits&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="c1"># Checking the validity of the selected clustering method</span>
    <span class="n">OnlyOnes</span> <span class="o">=</span> <span class="p">(</span><span class="n">plants</span><span class="p">[</span><span class="s1">&#39;Nunits&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;Standard&#39;</span><span class="p">,</span><span class="s1">&#39;MILP&#39;</span><span class="p">]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">OnlyOnes</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;The standard (or MILP) clustering method is only applicable if all values of the Nunits column in the power plant data are set to one. At least one different value has been encountered. No clustering will be applied&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;LP clustered&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">OnlyOnes</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;The LP clustering method aggregates all the units of the same type. Individual units are not considered&quot;</span><span class="p">)</span>
            <span class="c1"># Modifying the table to remove multiple-units plants:</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;PowerCapacity&#39;</span><span class="p">,</span> <span class="s1">&#39;STOCapacity&#39;</span><span class="p">,</span> <span class="s1">&#39;STOMaxChargingPower&#39;</span><span class="p">,</span><span class="s1">&#39;InitialPower&#39;</span><span class="p">,</span><span class="s1">&#39;CHPMaxHeat&#39;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">plants</span><span class="p">:</span>
                    <span class="n">plants</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">plants</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span><span class="s1">&#39;Nunits&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">plants</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span><span class="n">key</span><span class="p">]</span>
            <span class="n">plants</span><span class="p">[</span><span class="s1">&#39;Nunits&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">OnlyOnes</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;LP&#39;</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;Integer clustering&#39;</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;No clustering&#39;</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Method argument (&quot;&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">method</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;&quot;) not recognized in the clustering function&#39;</span><span class="p">)</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Number of units:</span>
    <span class="n">Nunits</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">plants</span><span class="p">)</span>
    <span class="n">plants</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">Nunits</span><span class="p">)</span>

    <span class="c1"># Definition of the mapping variable, from the old power plant list the new (merged) one:</span>
    <span class="n">map_old_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nunits</span><span class="p">)</span>
    <span class="n">map_plant_orig</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Slicing:</span>
    <span class="n">bounds</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;PartLoadMin&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Nslices</span><span class="p">),</span> <span class="s1">&#39;RampUpRate&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Nslices</span><span class="p">),</span>
              <span class="s1">&#39;RampDownRate&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Nslices</span><span class="p">),</span> <span class="s1">&#39;StartUpTime&#39;</span><span class="p">:</span> <span class="n">_mylogspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">36</span><span class="p">,</span> <span class="n">Nslices</span><span class="p">),</span>
              <span class="s1">&#39;MinUpTime&#39;</span><span class="p">:</span> <span class="n">_mylogspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">168</span><span class="p">,</span> <span class="n">Nslices</span><span class="p">),</span> <span class="s1">&#39;MinDownTime&#39;</span><span class="p">:</span> <span class="n">_mylogspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">168</span><span class="p">,</span> <span class="n">Nslices</span><span class="p">),</span>
              <span class="s1">&#39;NoLoadCost&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="n">Nslices</span><span class="p">),</span> <span class="s1">&#39;StartUpCost&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">500</span><span class="p">,</span> <span class="n">Nslices</span><span class="p">),</span>
              <span class="s1">&#39;Efficiency&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Nslices</span><span class="p">)}</span>

    <span class="c1"># Definition of the fingerprint value of each power plant, i.e. the pattern of the slices number in which each of</span>
    <span class="c1"># its characteristics falls:</span>
    <span class="n">fingerprints</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">fingerprints_merged</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">plants</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
        <span class="n">fingerprints</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">_find_nearest</span><span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="s1">&#39;PartLoadMin&#39;</span><span class="p">],</span> <span class="n">plants</span><span class="p">[</span><span class="s1">&#39;PartLoadMin&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]),</span>
                             <span class="n">_find_nearest</span><span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="s1">&#39;RampUpRate&#39;</span><span class="p">],</span> <span class="n">plants</span><span class="p">[</span><span class="s1">&#39;RampUpRate&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]),</span>
                             <span class="n">_find_nearest</span><span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="s1">&#39;RampDownRate&#39;</span><span class="p">],</span> <span class="n">plants</span><span class="p">[</span><span class="s1">&#39;RampDownRate&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]),</span>
                             <span class="n">_find_nearest</span><span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="s1">&#39;StartUpTime&#39;</span><span class="p">],</span> <span class="n">plants</span><span class="p">[</span><span class="s1">&#39;StartUpTime&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]),</span>
                             <span class="n">_find_nearest</span><span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="s1">&#39;MinUpTime&#39;</span><span class="p">],</span> <span class="n">plants</span><span class="p">[</span><span class="s1">&#39;MinUpTime&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]),</span>
                             <span class="n">_find_nearest</span><span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="s1">&#39;MinDownTime&#39;</span><span class="p">],</span> <span class="n">plants</span><span class="p">[</span><span class="s1">&#39;MinDownTime&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]),</span>
                             <span class="n">_find_nearest</span><span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="s1">&#39;NoLoadCost&#39;</span><span class="p">],</span> <span class="n">plants</span><span class="p">[</span><span class="s1">&#39;NoLoadCost&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]),</span>
                             <span class="n">_find_nearest</span><span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="s1">&#39;StartUpCost&#39;</span><span class="p">],</span> <span class="n">plants</span><span class="p">[</span><span class="s1">&#39;StartUpCost&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]),</span>
                             <span class="n">_find_nearest</span><span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="s1">&#39;Efficiency&#39;</span><span class="p">],</span> <span class="n">plants</span><span class="p">[</span><span class="s1">&#39;Efficiency&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">])])</span>

    <span class="c1"># Definition of the merged power plants dataframe:</span>
    <span class="n">plants_merged</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">plants</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>

    <span class="c1"># Find the columns containing string values (in addition to &quot;Unit&quot;)</span>
    <span class="c1">#    string_keys = []</span>
    <span class="c1">#    for i in range(len(plants.columns)):</span>
    <span class="c1">#        if plants.columns[i] != &#39;Unit&#39; and plants.dtypes[i] == np.dtype(&#39;O&#39;):</span>
    <span class="c1">#            string_keys.append(plants.columns[i])</span>
    <span class="n">string_keys</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Zone&#39;</span><span class="p">,</span> <span class="s1">&#39;Technology&#39;</span><span class="p">,</span> <span class="s1">&#39;Fuel&#39;</span><span class="p">,</span><span class="s1">&#39;CHPType&#39;</span><span class="p">]</span>
    <span class="c1"># First, fill nan values:</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">string_keys</span><span class="p">:</span>
        <span class="n">plants</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">plants</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>  <span class="c1"># i is the plant to be added to the new list</span>
        <span class="n">merged</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">plants_merged</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>  <span class="c1"># j corresponds to the clustered plants</span>
            <span class="n">same_type</span> <span class="o">=</span> <span class="nb">all</span><span class="p">([</span><span class="n">plants</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">plants_merged</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span>
                             <span class="n">string_keys</span><span class="p">])</span>
            <span class="n">same_fingerprint</span> <span class="o">=</span> <span class="p">(</span><span class="n">fingerprints</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">fingerprints_merged</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            <span class="n">low_pmin</span> <span class="o">=</span> <span class="p">(</span><span class="n">plants</span><span class="p">[</span><span class="s1">&#39;PartLoadMin&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">PartLoadMax</span><span class="p">)</span>
            <span class="n">low_pmax</span> <span class="o">=</span> <span class="p">(</span><span class="n">plants</span><span class="p">[</span><span class="s1">&#39;PowerCapacity&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">Pmax</span><span class="p">)</span>
            <span class="n">highly_flexible</span> <span class="o">=</span> <span class="n">plants</span><span class="p">[</span><span class="s1">&#39;RampUpRate&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">60</span> <span class="ow">and</span> <span class="p">(</span><span class="n">plants</span><span class="p">[</span><span class="s1">&#39;RampDownRate&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">60</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="n">plants</span><span class="p">[</span><span class="s1">&#39;StartUpTime&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">plants</span><span class="p">[</span><span class="s1">&#39;MinDownTime&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">plants</span><span class="p">[</span><span class="s1">&#39;MinUpTime&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">cluster</span> <span class="o">=</span> <span class="n">OnlyOnes</span> <span class="ow">and</span> <span class="n">same_type</span> <span class="ow">and</span> <span class="p">((</span><span class="n">same_fingerprint</span> <span class="ow">and</span> <span class="n">low_pmin</span><span class="p">)</span> <span class="ow">or</span> <span class="n">highly_flexible</span> <span class="ow">or</span> <span class="n">low_pmax</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;Standard&#39;</span><span class="p">,</span><span class="s1">&#39;MILP&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">cluster</span><span class="p">:</span>  <span class="c1"># merge the two plants in plants_merged:</span>
                <span class="n">P_old</span> <span class="o">=</span> <span class="n">plants_merged</span><span class="p">[</span><span class="s1">&#39;PowerCapacity&#39;</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>  <span class="c1"># Old power in plants_merged</span>
                <span class="n">P_add</span> <span class="o">=</span> <span class="n">plants</span><span class="p">[</span><span class="s1">&#39;PowerCapacity&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>  <span class="c1"># Additional power to be added</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">plants_merged</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;RampUpRate&#39;</span><span class="p">,</span> <span class="s1">&#39;RampDownRate&#39;</span><span class="p">,</span> <span class="s1">&#39;MinUpTime&#39;</span><span class="p">,</span> <span class="s1">&#39;MinDownTime&#39;</span><span class="p">,</span> <span class="s1">&#39;NoLoadCost&#39;</span><span class="p">,</span> <span class="s1">&#39;Efficiency&#39;</span><span class="p">,</span>
                               <span class="s1">&#39;MinEfficiency&#39;</span><span class="p">,</span> <span class="s1">&#39;STOChargingEfficiency&#39;</span><span class="p">,</span> <span class="s1">&#39;CO2Intensity&#39;</span><span class="p">,</span> <span class="s1">&#39;STOSelfDischarge&#39;</span><span class="p">,</span><span class="s1">&#39;CHPPowerToHeat&#39;</span><span class="p">,</span><span class="s1">&#39;CHPPowerLossFactor&#39;</span><span class="p">]:</span>
                        <span class="c1"># Do a weighted average:</span>
                        <span class="n">plants_merged</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">plants_merged</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">P_old</span> <span class="o">+</span> <span class="n">plants</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">P_add</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span>
                        <span class="n">P_add</span> <span class="o">+</span> <span class="n">P_old</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;PowerCapacity&#39;</span><span class="p">,</span> <span class="s1">&#39;STOCapacity&#39;</span><span class="p">,</span> <span class="s1">&#39;STOMaxChargingPower&#39;</span><span class="p">,</span><span class="s1">&#39;InitialPower&#39;</span><span class="p">,</span><span class="s1">&#39;CHPMaxHeat&#39;</span><span class="p">]:</span>
                        <span class="c1"># Do a sum:</span>
                        <span class="n">plants_merged</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">plants_merged</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">plants</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                    <span class="k">elif</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;PartLoadMin&#39;</span><span class="p">,</span> <span class="s1">&#39;StartUpTime&#39;</span><span class="p">]:</span>
                        <span class="c1"># Take the minimum</span>
                        <span class="n">plants_merged</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">plants_merged</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">P_old</span><span class="p">,</span>
                                                               <span class="n">plants</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">P_add</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">P_add</span> <span class="o">+</span> <span class="n">P_old</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;RampingCost&#39;</span><span class="p">:</span>
                        <span class="c1"># The starting cost must be added to the ramping cost</span>
                        <span class="n">Cost_to_fullload</span> <span class="o">=</span> <span class="n">P_add</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">plants</span><span class="p">[</span><span class="s1">&#39;PartLoadMin&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">])</span> <span class="o">*</span> <span class="n">plants</span><span class="p">[</span><span class="s1">&#39;RampingCost&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> \
                                           <span class="n">plants</span><span class="p">[</span><span class="s1">&#39;StartUpCost&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                        <span class="n">plants_merged</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">P_old</span> <span class="o">*</span> <span class="n">plants_merged</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">Cost_to_fullload</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">P_old</span> <span class="o">+</span> <span class="n">P_add</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;Nunits&#39;</span><span class="p">:</span>
                        <span class="n">plants_merged</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">map_old_new</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span>
                <span class="n">map_plant_orig</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">merged</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">break</span>
            <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;LP clustered&#39;</span> <span class="ow">and</span> <span class="n">same_type</span> <span class="ow">and</span> <span class="n">OnlyOnes</span><span class="p">:</span>
                <span class="n">P_old</span> <span class="o">=</span> <span class="n">plants_merged</span><span class="p">[</span><span class="s1">&#39;PowerCapacity&#39;</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>  <span class="c1"># Old power in plants_merged</span>
                <span class="n">P_add</span> <span class="o">=</span> <span class="n">plants</span><span class="p">[</span><span class="s1">&#39;PowerCapacity&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>  <span class="c1"># Additional power to be added</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">plants_merged</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;RampUpRate&#39;</span><span class="p">,</span> <span class="s1">&#39;RampDownRate&#39;</span><span class="p">,</span> <span class="s1">&#39;MinUpTime&#39;</span><span class="p">,</span> <span class="s1">&#39;MinDownTime&#39;</span><span class="p">,</span> <span class="s1">&#39;NoLoadCost&#39;</span><span class="p">,</span> <span class="s1">&#39;Efficiency&#39;</span><span class="p">,</span>
                               <span class="s1">&#39;MinEfficiency&#39;</span><span class="p">,</span> <span class="s1">&#39;STOChargingEfficiency&#39;</span><span class="p">,</span> <span class="s1">&#39;CO2Intensity&#39;</span><span class="p">,</span> <span class="s1">&#39;STOSelfDischarge&#39;</span><span class="p">]:</span>
                        <span class="c1"># Do a weighted average:</span>
                        <span class="n">plants_merged</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">plants_merged</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">P_old</span> <span class="o">+</span> <span class="n">plants</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">P_add</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span>
                        <span class="n">P_add</span> <span class="o">+</span> <span class="n">P_old</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;PowerCapacity&#39;</span><span class="p">,</span> <span class="s1">&#39;STOCapacity&#39;</span><span class="p">,</span> <span class="s1">&#39;STOMaxChargingPower&#39;</span><span class="p">,</span><span class="s1">&#39;InitialPower&#39;</span><span class="p">,</span><span class="s1">&#39;CHPMaxHeat&#39;</span><span class="p">]:</span>
                        <span class="c1"># Do a sum:</span>
                        <span class="n">plants_merged</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">plants_merged</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">plants</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                    <span class="k">elif</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;PartLoadMin&#39;</span><span class="p">,</span> <span class="s1">&#39;StartUpTime&#39;</span><span class="p">]:</span>
                        <span class="c1"># impose 0</span>
                        <span class="n">plants_merged</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;RampingCost&#39;</span><span class="p">:</span>
                        <span class="c1"># The starting cost must be added to the ramping cost</span>
                        <span class="n">Cost_to_fullload</span> <span class="o">=</span> <span class="n">P_add</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">plants</span><span class="p">[</span><span class="s1">&#39;PartLoadMin&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">])</span> <span class="o">*</span> <span class="n">plants</span><span class="p">[</span><span class="s1">&#39;RampingCost&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> \
                                           <span class="n">plants</span><span class="p">[</span><span class="s1">&#39;StartUpCost&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                        <span class="n">plants_merged</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">P_old</span> <span class="o">*</span> <span class="n">plants_merged</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">Cost_to_fullload</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">P_old</span> <span class="o">+</span> <span class="n">P_add</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;Nunits&#39;</span><span class="p">:</span>
                        <span class="n">plants_merged</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">map_old_new</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span>
                <span class="n">map_plant_orig</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">merged</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">break</span>
            <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;Integer clustering&#39;</span> <span class="ow">and</span> <span class="n">same_type</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">plants_merged</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;PowerCapacity&#39;</span><span class="p">,</span><span class="s1">&#39;RampUpRate&#39;</span><span class="p">,</span> <span class="s1">&#39;RampDownRate&#39;</span><span class="p">,</span> <span class="s1">&#39;MinUpTime&#39;</span><span class="p">,</span> <span class="s1">&#39;MinDownTime&#39;</span><span class="p">,</span> <span class="s1">&#39;NoLoadCost&#39;</span><span class="p">,</span> <span class="s1">&#39;Efficiency&#39;</span><span class="p">,</span>
                               <span class="s1">&#39;MinEfficiency&#39;</span><span class="p">,</span> <span class="s1">&#39;STOChargingEfficiency&#39;</span><span class="p">,</span> <span class="s1">&#39;CO2Intensity&#39;</span><span class="p">,</span> <span class="s1">&#39;STOSelfDischarge&#39;</span><span class="p">,</span>
                               <span class="s1">&#39;STOCapacity&#39;</span><span class="p">,</span> <span class="s1">&#39;STOMaxChargingPower&#39;</span><span class="p">,</span><span class="s1">&#39;InitialPower&#39;</span><span class="p">,</span><span class="s1">&#39;PartLoadMin&#39;</span><span class="p">,</span> <span class="s1">&#39;StartUpTime&#39;</span><span class="p">,</span><span class="s1">&#39;RampingCost&#39;</span><span class="p">,</span>
                               <span class="s1">&#39;CHPPowerToHeat&#39;</span><span class="p">,</span><span class="s1">&#39;CHPPowerLossFactor&#39;</span><span class="p">,</span><span class="s1">&#39;CHPMaxHeat&#39;</span><span class="p">]:</span>
                        <span class="c1"># Do a weighted average:</span>
                        <span class="n">plants_merged</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">plants_merged</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">key</span><span class="p">]</span> <span class="o">*</span> <span class="n">plants_merged</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="s1">&#39;Nunits&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">plants</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">key</span><span class="p">]</span> <span class="o">*</span> <span class="n">plants</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="s1">&#39;Nunits&#39;</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">plants_merged</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="s1">&#39;Nunits&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">plants</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="s1">&#39;Nunits&#39;</span><span class="p">])</span>
                <span class="n">plants_merged</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="s1">&#39;Nunits&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">plants_merged</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="s1">&#39;Nunits&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">plants</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="s1">&#39;Nunits&#39;</span><span class="p">]</span>
                        
                <span class="n">map_old_new</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span>
                <span class="n">map_plant_orig</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">merged</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">break</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">merged</span><span class="p">:</span>  <span class="c1"># Add a new plant in plants_merged:</span>
            <span class="n">plants_merged</span> <span class="o">=</span> <span class="n">plants_merged</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">plants</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">plants_merged</span> <span class="o">=</span> <span class="n">plants_merged</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">map_plant_orig</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="p">])</span>
            <span class="n">map_old_new</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">map_plant_orig</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">fingerprints_merged</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fingerprints</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="n">Nunits_merged</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">plants_merged</span><span class="p">)</span>
    <span class="n">mapping</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;NewIndex&#39;</span><span class="p">:</span> <span class="p">{},</span> <span class="s1">&#39;FormerIndexes&#39;</span><span class="p">:</span> <span class="p">{}}</span>
    <span class="c1">#    mapping[&#39;NewIdx&#39;] = map_plant_orig</span>
    <span class="c1">#    mapping[&#39;OldIdx&#39;] = map_old_new</span>
    <span class="c1"># Modify the Unit names with the original index number. In case of merged plants, indicate all indexes + the plant type and fuel</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Nunits_merged</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">map_plant_orig</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># The plant has not been merged</span>
            <span class="n">NewName</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">map_plant_orig</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">+</span> <span class="s1">&#39; - &#39;</span> <span class="o">+</span> <span class="n">plants_merged</span><span class="p">[</span><span class="s1">&#39;Unit&#39;</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
            <span class="n">NewName</span> <span class="o">=</span> <span class="n">shrink_to_64</span><span class="p">(</span><span class="n">clean_strings</span><span class="p">(</span><span class="n">NewName</span><span class="p">))</span>
            <span class="n">NewName</span> <span class="o">=</span> <span class="n">NewName</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span>                          <span class="c1"># remove space at the end because it is not considered by gams</span>
            <span class="n">plants_merged</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="s1">&#39;Unit&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">NewName</span>
            <span class="n">mapping</span><span class="p">[</span><span class="s1">&#39;FormerIndexes&#39;</span><span class="p">][</span><span class="n">NewName</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">map_plant_orig</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">mapping</span><span class="p">[</span><span class="s1">&#39;NewIndex&#39;</span><span class="p">][</span><span class="n">map_plant_orig</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">NewName</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">all_stringkeys</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">string_keys</span><span class="p">:</span>
                <span class="n">all_stringkeys</span> <span class="o">=</span> <span class="n">all_stringkeys</span> <span class="o">+</span> <span class="s1">&#39; - &#39;</span> <span class="o">+</span> <span class="n">plants_merged</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
            <span class="n">NewName</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">map_plant_orig</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">+</span> <span class="n">all_stringkeys</span>
            <span class="n">NewName</span> <span class="o">=</span> <span class="n">shrink_to_64</span><span class="p">(</span><span class="n">clean_strings</span><span class="p">(</span><span class="n">NewName</span><span class="p">))</span>
            <span class="n">NewName</span> <span class="o">=</span> <span class="n">NewName</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span>                          <span class="c1"># remove space at the end because it is not considered by gams</span>
            <span class="n">plants_merged</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="s1">&#39;Unit&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">NewName</span>
            <span class="n">list_oldplants</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">map_plant_orig</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span>
            <span class="n">mapping</span><span class="p">[</span><span class="s1">&#39;FormerIndexes&#39;</span><span class="p">][</span><span class="n">NewName</span><span class="p">]</span> <span class="o">=</span> <span class="n">list_oldplants</span>
            <span class="k">for</span> <span class="n">oldplant</span> <span class="ow">in</span> <span class="n">list_oldplants</span><span class="p">:</span>
                <span class="n">mapping</span><span class="p">[</span><span class="s1">&#39;NewIndex&#39;</span><span class="p">][</span><span class="n">oldplant</span><span class="p">]</span> <span class="o">=</span> <span class="n">NewName</span>

    <span class="c1"># Transforming the start-up cost into ramping for the plants that did not go through any clustering:</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;LP clustered&#39;</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Nunits_merged</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">plants_merged</span><span class="p">[</span><span class="s1">&#39;RampingCost&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">Power</span> <span class="o">=</span> <span class="n">plants_merged</span><span class="p">[</span><span class="s1">&#39;PowerCapacity&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                <span class="n">Start_up</span> <span class="o">=</span> <span class="n">plants_merged</span><span class="p">[</span><span class="s1">&#39;StartUpCost&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                <span class="n">plants_merged</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="s1">&#39;RampingCost&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Start_up</span> <span class="o">/</span> <span class="n">Power</span>
                
    <span class="c1"># Correcting the Nunits field of the clustered plants (must be integer):</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;Integer clustering&#39;</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">plants_merged</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
            <span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">plants_merged</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span><span class="s1">&#39;Nunits&#39;</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;PowerCapacity&#39;</span><span class="p">,</span> <span class="s1">&#39;STOCapacity&#39;</span><span class="p">,</span> <span class="s1">&#39;STOMaxChargingPower&#39;</span><span class="p">,</span><span class="s1">&#39;InitialPower&#39;</span><span class="p">,</span><span class="s1">&#39;NoLoadCost&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">plants_merged</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="n">plants_merged</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">plants_merged</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span><span class="n">key</span><span class="p">]</span> <span class="o">*</span> <span class="n">N</span> <span class="o">/</span> <span class="n">plants_merged</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span><span class="s1">&#39;Nunits&#39;</span><span class="p">]</span>
        <span class="n">plants_merged</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span><span class="s1">&#39;Nunits&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">N</span>
                
    <span class="c1"># Updating the index of the merged plants dataframe with the new unit names, after some cleaning:</span>
    <span class="n">plants_merged</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">plants_merged</span><span class="p">[</span><span class="s1">&#39;Unit&#39;</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">Nunits</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">plants_merged</span><span class="p">):</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Clustered &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">Nunits</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; original units into &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">plants_merged</span><span class="p">))</span> <span class="o">+</span> <span class="s1">&#39; new units&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Did not cluster any unit&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">plants_merged</span><span class="p">,</span> <span class="n">mapping</span></div>

<span class="c1">## Helpers</span>

<span class="k">def</span> <span class="nf">_mylogspace</span><span class="p">(</span><span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Self-defined logspace function in which low and high are the first and last values of the space</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># shifting all values so that low = 1</span>
    <span class="n">space</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">high</span> <span class="o">+</span> <span class="n">low</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">N</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">low</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">space</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_find_nearest</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Self-defined function to find the index of the nearest value in a vector</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">array</span> <span class="o">-</span> <span class="n">value</span><span class="p">))</span><span class="o">.</span><span class="n">argmin</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">idx</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, Sylvain Quoilin &amp; Kostas Kavvadias

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../../../',
              VERSION:'',
              LANGUAGE:'None',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../_static/doctools.js"></script>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    

  

  <script type="text/javascript" src="../../../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>